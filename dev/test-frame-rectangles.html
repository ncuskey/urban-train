<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test Frame Rectangles - Ocean Label Placement</title>
  <style>
    body { font-family: monospace; margin: 20px; }
    .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; }
    .success { background: #d4edda; border-color: #c3e6cb; }
    .error { background: #f8d7da; border-color: #f5c6cb; }
    pre { background: #f8f9fa; padding: 10px; overflow-x: auto; }
    .frame-visualization { margin: 20px 0; }
    .frame-rect { 
      position: absolute; 
      border: 2px solid; 
      opacity: 0.7; 
      pointer-events: none;
    }
    .frame-top { border-color: #ff6b6b; background: rgba(255, 107, 107, 0.1); }
    .frame-bottom { border-color: #4ecdc4; background: rgba(78, 205, 196, 0.1); }
    .frame-left { border-color: #45b7d1; background: rgba(69, 183, 209, 0.1); }
    .frame-right { border-color: #96ceb4; background: rgba(150, 206, 180, 0.1); }
    .land-bbox { 
      position: absolute; 
      border: 3px solid #8b4513; 
      background: rgba(139, 69, 19, 0.1);
      pointer-events: none;
    }
    .viewport { 
      position: relative; 
      width: 800px; 
      height: 400px; 
      border: 2px solid #333; 
      margin: 20px 0;
      background: #f0f8ff;
    }
  </style>
</head>
<body>
  <h1>Test Frame Rectangles - Ocean Label Placement</h1>
  
  <div class="test-section">
    <h2>Test Setup</h2>
    <p>This test verifies the frame rectangle computation when SAT misses for ocean label placement.</p>
    <button id="runTest">Run Test</button>
    <div id="testResults"></div>
  </div>

  <div class="test-section">
    <h2>Frame Rectangle Visualization</h2>
    <p>Shows the 4 frame rectangles (top/bottom/left/right) around the land area:</p>
    <div class="viewport" id="viewport">
      <!-- Frame rectangles will be added here -->
    </div>
    <div id="frameDetails"></div>
  </div>

  <script type="module">
    // Mock the helper functions to test the logic
    function computeLandBBoxScreen(cells, getHeight, getXY, seaLevel) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity, count = 0;
      for (let i = 0; i < cells.length; i++) {
        const h = getHeight(i);
        if (h > seaLevel) {
          const [x, y] = getXY(i); // screen coords
          if (x < minX) minX = x; if (x > maxX) maxX = x;
          if (y < minY) minY = y; if (y > maxY) maxY = y;
          count++;
        }
      }
      if (!count || !Number.isFinite(minX)) return null;
      return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
    }

    function chooseLargestFrameRect(viewportW, viewportH, landRect, margin = 8) {
      if (!landRect) return { x: margin, y: margin, w: viewportW - 2*margin, h: viewportH - 2*margin };
      const L = Math.max(0, landRect.x - margin);
      const T = Math.max(0, landRect.y - margin);
      const R = Math.min(viewportW, landRect.x + landRect.w + margin);
      const B = Math.min(viewportH, landRect.y + landRect.h + margin);

      const frames = [
        { x: 0, y: 0, w: viewportW, h: T,                  side: "top"    },
        { x: 0, y: B, w: viewportW, h: viewportH - B,      side: "bottom" },
        { x: 0, y: T, w: L,            h: Math.max(0, B-T), side: "left"   },
        { x: R, y: T, w: viewportW-R,  h: Math.max(0, B-T), side: "right"  },
      ].filter(r => r.w > 16 && r.h > 16);

      if (!frames.length) return null;
      frames.sort((a, b) => (b.w*b.h) - (a.w*a.h));
      return frames[0];
    }

    function runTest() {
      const resultsDiv = document.getElementById('testResults');
      const viewportDiv = document.getElementById('viewport');
      const frameDetailsDiv = document.getElementById('frameDetails');
      
      resultsDiv.innerHTML = '<p>Running test...</p>';
      
      // Clear previous visualization
      viewportDiv.innerHTML = '';
      
      try {
        // Test case 1: Island in center (typical island-in-ocean scenario)
        const testCells = [
          // Land cells (height > 0.2)
          { height: 0.8, points: [[300, 150], [350, 150], [350, 200], [300, 200]] },
          { height: 0.7, points: [[350, 150], [400, 150], [400, 200], [350, 200]] },
          { height: 0.9, points: [[300, 200], [400, 200], [400, 250], [300, 250]] },
          // Water cells (height <= 0.2)
          { height: 0.1, points: [[100, 100], [200, 100], [200, 150], [100, 150]] },
          { height: 0.15, points: [[500, 100], [600, 100], [600, 150], [500, 150]] },
          { height: 0.05, points: [[100, 250], [200, 250], [200, 300], [100, 300]] },
          { height: 0.12, points: [[500, 250], [600, 250], [600, 300], [500, 300]] },
        ];

        const viewportW = 800;
        const viewportH = 400;
        const seaLevel = 0.20;
        const margin = 10;

        // Create accessor functions
        const getHeight = (i) => testCells[i]?.height ?? 0;
        const getXY = (i) => {
          const cell = testCells[i];
          if (!cell || !Array.isArray(cell.points) || cell.points.length === 0) return [0, 0];
          // Calculate centroid from polygon vertices
          let cx = 0, cy = 0, count = 0;
          cell.points.forEach(vertex => {
            if (vertex && vertex.length >= 2) {
              cx += vertex[0];
              cy += vertex[1];
              count++;
            }
          });
          return count > 0 ? [cx / count, cy / count] : [0, 0];
        };

        // Compute land bbox
        const landRect = computeLandBBoxScreen(testCells, getHeight, getXY, seaLevel);
        
        if (!landRect) {
          resultsDiv.innerHTML = '<div class="error"><strong>❌ FAIL:</strong> No land bbox computed</div>';
          return;
        }

        // Choose largest frame rectangle
        const frame = chooseLargestFrameRect(viewportW, viewportH, landRect, margin);
        
        if (!frame) {
          resultsDiv.innerHTML = '<div class="error"><strong>❌ FAIL:</strong> No frame rectangle found</div>';
          return;
        }

        // Display results
        resultsDiv.innerHTML = `
          <div class="success">
            <strong>✅ PASS:</strong> Frame rectangle computation successful
            <ul>
              <li>Land bbox: ${JSON.stringify(landRect)}</li>
              <li>Selected frame: ${JSON.stringify(frame)} (${frame.side})</li>
              <li>Frame area: ${frame.w * frame.h} px²</li>
            </ul>
          </div>
        `;

                 // Visualize the frame rectangles
         visualizeFrames(viewportDiv, landRect, frame, viewportW, viewportH, margin);
         
         // Show frame details
         frameDetailsDiv.innerHTML = `
           <h3>Frame Analysis</h3>
           <p><strong>Land Area:</strong> ${landRect.w} × ${landRect.h} = ${landRect.w * landRect.h} px²</p>
           <p><strong>Selected Frame:</strong> ${frame.side} (${frame.w} × ${frame.h} = ${frame.w * frame.h} px²)</p>
           <p><strong>Margin:</strong> ${margin}px</p>
           <p><strong>Debug:</strong> Frame rectangle outline will be drawn in the main app using <code>drawOceanDebugRect()</code></p>
         `;

      } catch (error) {
        resultsDiv.innerHTML = `
          <div class="error">
            <strong>❌ ERROR:</strong> ${error.message}
            <pre>${error.stack}</pre>
          </div>
        `;
      }
    }

    function visualizeFrames(container, landRect, selectedFrame, viewportW, viewportH, margin) {
      // Draw land bbox
      const landBbox = document.createElement('div');
      landBbox.className = 'land-bbox';
      landBbox.style.left = landRect.x + 'px';
      landBbox.style.top = landRect.y + 'px';
      landBbox.style.width = landRect.w + 'px';
      landBbox.style.height = landRect.h + 'px';
      container.appendChild(landBbox);

      // Calculate frame boundaries
      const L = Math.max(0, landRect.x - margin);
      const T = Math.max(0, landRect.y - margin);
      const R = Math.min(viewportW, landRect.x + landRect.w + margin);
      const B = Math.min(viewportH, landRect.y + landRect.h + margin);

      // Create all frame rectangles
      const frames = [
        { x: 0, y: 0, w: viewportW, h: T, side: "top", class: "frame-top" },
        { x: 0, y: B, w: viewportW, h: viewportH - B, side: "bottom", class: "frame-bottom" },
        { x: 0, y: T, w: L, h: Math.max(0, B-T), side: "left", class: "frame-left" },
        { x: R, y: T, w: viewportW-R, h: Math.max(0, B-T), side: "right", class: "frame-right" },
      ].filter(r => r.w > 16 && r.h > 16);

      frames.forEach(frame => {
        const frameDiv = document.createElement('div');
        frameDiv.className = `frame-rect ${frame.class}`;
        frameDiv.style.left = frame.x + 'px';
        frameDiv.style.top = frame.y + 'px';
        frameDiv.style.width = frame.w + 'px';
        frameDiv.style.height = frame.h + 'px';
        frameDiv.title = `${frame.side}: ${frame.w}×${frame.h} = ${frame.w * frame.h} px²`;
        container.appendChild(frameDiv);
      });

      // Highlight selected frame
      const selectedDiv = container.querySelector(`.frame-${selectedFrame.side}`);
      if (selectedDiv) {
        selectedDiv.style.borderWidth = '4px';
        selectedDiv.style.opacity = '1';
      }
    }

    // Attach test button
    document.getElementById('runTest').addEventListener('click', runTest);
    
    // Auto-run test on load
    window.addEventListener('load', () => {
      setTimeout(runTest, 100);
    });
  </script>
</body>
</html>
